/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "alpha_trade_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




HoldingStock::~HoldingStock() throw() {
}


void HoldingStock::__set_stock_id(const std::string& val) {
  this->stock_id = val;
}

void HoldingStock::__set_buy_price(const double val) {
  this->buy_price = val;
}

void HoldingStock::__set_long_short(const std::string& val) {
  this->long_short = val;
}

void HoldingStock::__set_quant(const double val) {
  this->quant = val;
}

void HoldingStock::__set_quant_sellable(const double val) {
  this->quant_sellable = val;
}

uint32_t HoldingStock::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stock_id);
          this->__isset.stock_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->buy_price);
          this->__isset.buy_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->long_short);
          this->__isset.long_short = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quant);
          this->__isset.quant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quant_sellable);
          this->__isset.quant_sellable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HoldingStock::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HoldingStock");

  xfer += oprot->writeFieldBegin("stock_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stock_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buy_price", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->buy_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("long_short", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->long_short);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quant", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->quant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quant_sellable", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->quant_sellable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HoldingStock &a, HoldingStock &b) {
  using ::std::swap;
  swap(a.stock_id, b.stock_id);
  swap(a.buy_price, b.buy_price);
  swap(a.long_short, b.long_short);
  swap(a.quant, b.quant);
  swap(a.quant_sellable, b.quant_sellable);
  swap(a.__isset, b.__isset);
}

HoldingStock::HoldingStock(const HoldingStock& other0) {
  stock_id = other0.stock_id;
  buy_price = other0.buy_price;
  long_short = other0.long_short;
  quant = other0.quant;
  quant_sellable = other0.quant_sellable;
  __isset = other0.__isset;
}
HoldingStock& HoldingStock::operator=(const HoldingStock& other1) {
  stock_id = other1.stock_id;
  buy_price = other1.buy_price;
  long_short = other1.long_short;
  quant = other1.quant;
  quant_sellable = other1.quant_sellable;
  __isset = other1.__isset;
  return *this;
}
void HoldingStock::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HoldingStock(";
  out << "stock_id=" << to_string(stock_id);
  out << ", " << "buy_price=" << to_string(buy_price);
  out << ", " << "long_short=" << to_string(long_short);
  out << ", " << "quant=" << to_string(quant);
  out << ", " << "quant_sellable=" << to_string(quant_sellable);
  out << ")";
}


AccountBalance::~AccountBalance() throw() {
}


void AccountBalance::__set_total_value(const double val) {
  this->total_value = val;
}

void AccountBalance::__set_money_left(const double val) {
  this->money_left = val;
}

uint32_t AccountBalance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->total_value);
          this->__isset.total_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->money_left);
          this->__isset.money_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccountBalance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccountBalance");

  xfer += oprot->writeFieldBegin("total_value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->total_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("money_left", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->money_left);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccountBalance &a, AccountBalance &b) {
  using ::std::swap;
  swap(a.total_value, b.total_value);
  swap(a.money_left, b.money_left);
  swap(a.__isset, b.__isset);
}

AccountBalance::AccountBalance(const AccountBalance& other2) {
  total_value = other2.total_value;
  money_left = other2.money_left;
  __isset = other2.__isset;
}
AccountBalance& AccountBalance::operator=(const AccountBalance& other3) {
  total_value = other3.total_value;
  money_left = other3.money_left;
  __isset = other3.__isset;
  return *this;
}
void AccountBalance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccountBalance(";
  out << "total_value=" << to_string(total_value);
  out << ", " << "money_left=" << to_string(money_left);
  out << ")";
}


OrderState::~OrderState() throw() {
}


void OrderState::__set_order_id(const std::string& val) {
  this->order_id = val;
}

void OrderState::__set_time(const std::string& val) {
  this->time = val;
}

void OrderState::__set_sid(const std::string& val) {
  this->sid = val;
}

void OrderState::__set_internal_order_id(const std::string& val) {
  this->internal_order_id = val;
}

void OrderState::__set_operation(const std::string& val) {
  this->operation = val;
}

void OrderState::__set_direction(const std::string& val) {
  this->direction = val;
}

void OrderState::__set_price(const double val) {
  this->price = val;
}

void OrderState::__set_quant(const double val) {
  this->quant = val;
}

void OrderState::__set_deal_quant(const double val) {
  this->deal_quant = val;
}

void OrderState::__set_deal_price(const double val) {
  this->deal_price = val;
}

void OrderState::__set_state(const std::string& val) {
  this->state = val;
}

void OrderState::__set_desc(const std::string& val) {
  this->desc = val;
}

uint32_t OrderState::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->order_id);
          this->__isset.order_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sid);
          this->__isset.sid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->internal_order_id);
          this->__isset.internal_order_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operation);
          this->__isset.operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quant);
          this->__isset.quant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->deal_quant);
          this->__isset.deal_quant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->deal_price);
          this->__isset.deal_price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          this->__isset.desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OrderState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OrderState");

  xfer += oprot->writeFieldBegin("order_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->order_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("internal_order_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->internal_order_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->operation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quant", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->quant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deal_quant", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->deal_quant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deal_price", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->deal_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OrderState &a, OrderState &b) {
  using ::std::swap;
  swap(a.order_id, b.order_id);
  swap(a.time, b.time);
  swap(a.sid, b.sid);
  swap(a.internal_order_id, b.internal_order_id);
  swap(a.operation, b.operation);
  swap(a.direction, b.direction);
  swap(a.price, b.price);
  swap(a.quant, b.quant);
  swap(a.deal_quant, b.deal_quant);
  swap(a.deal_price, b.deal_price);
  swap(a.state, b.state);
  swap(a.desc, b.desc);
  swap(a.__isset, b.__isset);
}

OrderState::OrderState(const OrderState& other4) {
  order_id = other4.order_id;
  time = other4.time;
  sid = other4.sid;
  internal_order_id = other4.internal_order_id;
  operation = other4.operation;
  direction = other4.direction;
  price = other4.price;
  quant = other4.quant;
  deal_quant = other4.deal_quant;
  deal_price = other4.deal_price;
  state = other4.state;
  desc = other4.desc;
  __isset = other4.__isset;
}
OrderState& OrderState::operator=(const OrderState& other5) {
  order_id = other5.order_id;
  time = other5.time;
  sid = other5.sid;
  internal_order_id = other5.internal_order_id;
  operation = other5.operation;
  direction = other5.direction;
  price = other5.price;
  quant = other5.quant;
  deal_quant = other5.deal_quant;
  deal_price = other5.deal_price;
  state = other5.state;
  desc = other5.desc;
  __isset = other5.__isset;
  return *this;
}
void OrderState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OrderState(";
  out << "order_id=" << to_string(order_id);
  out << ", " << "time=" << to_string(time);
  out << ", " << "sid=" << to_string(sid);
  out << ", " << "internal_order_id=" << to_string(internal_order_id);
  out << ", " << "operation=" << to_string(operation);
  out << ", " << "direction=" << to_string(direction);
  out << ", " << "price=" << to_string(price);
  out << ", " << "quant=" << to_string(quant);
  out << ", " << "deal_quant=" << to_string(deal_quant);
  out << ", " << "deal_price=" << to_string(deal_price);
  out << ", " << "state=" << to_string(state);
  out << ", " << "desc=" << to_string(desc);
  out << ")";
}


LiveTradeLoginResp::~LiveTradeLoginResp() throw() {
}


void LiveTradeLoginResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void LiveTradeLoginResp::__set_result(const std::string& val) {
  this->result = val;
}

uint32_t LiveTradeLoginResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LiveTradeLoginResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LiveTradeLoginResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LiveTradeLoginResp &a, LiveTradeLoginResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

LiveTradeLoginResp::LiveTradeLoginResp(const LiveTradeLoginResp& other6) {
  ret_code = other6.ret_code;
  result = other6.result;
  __isset = other6.__isset;
}
LiveTradeLoginResp& LiveTradeLoginResp::operator=(const LiveTradeLoginResp& other7) {
  ret_code = other7.ret_code;
  result = other7.result;
  __isset = other7.__isset;
  return *this;
}
void LiveTradeLoginResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LiveTradeLoginResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


LiveTradeLogoutResp::~LiveTradeLogoutResp() throw() {
}


void LiveTradeLogoutResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

uint32_t LiveTradeLogoutResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LiveTradeLogoutResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LiveTradeLogoutResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LiveTradeLogoutResp &a, LiveTradeLogoutResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.__isset, b.__isset);
}

LiveTradeLogoutResp::LiveTradeLogoutResp(const LiveTradeLogoutResp& other8) {
  ret_code = other8.ret_code;
  __isset = other8.__isset;
}
LiveTradeLogoutResp& LiveTradeLogoutResp::operator=(const LiveTradeLogoutResp& other9) {
  ret_code = other9.ret_code;
  __isset = other9.__isset;
  return *this;
}
void LiveTradeLogoutResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LiveTradeLogoutResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ")";
}


GetAccountStateResp::~GetAccountStateResp() throw() {
}


void GetAccountStateResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GetAccountStateResp::__set_state(const std::string& val) {
  this->state = val;
}

void GetAccountStateResp::__set_desc(const std::string& val) {
  this->desc = val;
}

uint32_t GetAccountStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          this->__isset.desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAccountStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAccountStateResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAccountStateResp &a, GetAccountStateResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.state, b.state);
  swap(a.desc, b.desc);
  swap(a.__isset, b.__isset);
}

GetAccountStateResp::GetAccountStateResp(const GetAccountStateResp& other10) {
  ret_code = other10.ret_code;
  state = other10.state;
  desc = other10.desc;
  __isset = other10.__isset;
}
GetAccountStateResp& GetAccountStateResp::operator=(const GetAccountStateResp& other11) {
  ret_code = other11.ret_code;
  state = other11.state;
  desc = other11.desc;
  __isset = other11.__isset;
  return *this;
}
void GetAccountStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAccountStateResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "state=" << to_string(state);
  out << ", " << "desc=" << to_string(desc);
  out << ")";
}


GetAccountBalanceResp::~GetAccountBalanceResp() throw() {
}


void GetAccountBalanceResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GetAccountBalanceResp::__set_result(const AccountBalance& val) {
  this->result = val;
}

uint32_t GetAccountBalanceResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAccountBalanceResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAccountBalanceResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAccountBalanceResp &a, GetAccountBalanceResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

GetAccountBalanceResp::GetAccountBalanceResp(const GetAccountBalanceResp& other12) {
  ret_code = other12.ret_code;
  result = other12.result;
  __isset = other12.__isset;
}
GetAccountBalanceResp& GetAccountBalanceResp::operator=(const GetAccountBalanceResp& other13) {
  ret_code = other13.ret_code;
  result = other13.result;
  __isset = other13.__isset;
  return *this;
}
void GetAccountBalanceResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAccountBalanceResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


GetHoldingStockResp::~GetHoldingStockResp() throw() {
}


void GetHoldingStockResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GetHoldingStockResp::__set_result(const std::vector<HoldingStock> & val) {
  this->result = val;
}

uint32_t GetHoldingStockResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->result.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->result[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetHoldingStockResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetHoldingStockResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result.size()));
    std::vector<HoldingStock> ::const_iterator _iter19;
    for (_iter19 = this->result.begin(); _iter19 != this->result.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetHoldingStockResp &a, GetHoldingStockResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

GetHoldingStockResp::GetHoldingStockResp(const GetHoldingStockResp& other20) {
  ret_code = other20.ret_code;
  result = other20.result;
  __isset = other20.__isset;
}
GetHoldingStockResp& GetHoldingStockResp::operator=(const GetHoldingStockResp& other21) {
  ret_code = other21.ret_code;
  result = other21.result;
  __isset = other21.__isset;
  return *this;
}
void GetHoldingStockResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetHoldingStockResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


GetAllOrderResp::~GetAllOrderResp() throw() {
}


void GetAllOrderResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GetAllOrderResp::__set_result(const std::vector<OrderState> & val) {
  this->result = val;
}

uint32_t GetAllOrderResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->result.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->result[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAllOrderResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllOrderResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result.size()));
    std::vector<OrderState> ::const_iterator _iter27;
    for (_iter27 = this->result.begin(); _iter27 != this->result.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllOrderResp &a, GetAllOrderResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

GetAllOrderResp::GetAllOrderResp(const GetAllOrderResp& other28) {
  ret_code = other28.ret_code;
  result = other28.result;
  __isset = other28.__isset;
}
GetAllOrderResp& GetAllOrderResp::operator=(const GetAllOrderResp& other29) {
  ret_code = other29.ret_code;
  result = other29.result;
  __isset = other29.__isset;
  return *this;
}
void GetAllOrderResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllOrderResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


GetOrderStateResp::~GetOrderStateResp() throw() {
}


void GetOrderStateResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GetOrderStateResp::__set_result(const OrderState& val) {
  this->result = val;
}

uint32_t GetOrderStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetOrderStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOrderStateResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOrderStateResp &a, GetOrderStateResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

GetOrderStateResp::GetOrderStateResp(const GetOrderStateResp& other30) {
  ret_code = other30.ret_code;
  result = other30.result;
  __isset = other30.__isset;
}
GetOrderStateResp& GetOrderStateResp::operator=(const GetOrderStateResp& other31) {
  ret_code = other31.ret_code;
  result = other31.result;
  __isset = other31.__isset;
  return *this;
}
void GetOrderStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOrderStateResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


CloseOrderResp::~CloseOrderResp() throw() {
}


void CloseOrderResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

uint32_t CloseOrderResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CloseOrderResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CloseOrderResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CloseOrderResp &a, CloseOrderResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.__isset, b.__isset);
}

CloseOrderResp::CloseOrderResp(const CloseOrderResp& other32) {
  ret_code = other32.ret_code;
  __isset = other32.__isset;
}
CloseOrderResp& CloseOrderResp::operator=(const CloseOrderResp& other33) {
  ret_code = other33.ret_code;
  __isset = other33.__isset;
  return *this;
}
void CloseOrderResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CloseOrderResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ")";
}


CancelOrderResp::~CancelOrderResp() throw() {
}


void CancelOrderResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

uint32_t CancelOrderResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CancelOrderResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelOrderResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelOrderResp &a, CancelOrderResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.__isset, b.__isset);
}

CancelOrderResp::CancelOrderResp(const CancelOrderResp& other34) {
  ret_code = other34.ret_code;
  __isset = other34.__isset;
}
CancelOrderResp& CancelOrderResp::operator=(const CancelOrderResp& other35) {
  ret_code = other35.ret_code;
  __isset = other35.__isset;
  return *this;
}
void CancelOrderResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelOrderResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ")";
}


PlaceOrderResp::~PlaceOrderResp() throw() {
}


void PlaceOrderResp::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void PlaceOrderResp::__set_result(const std::string& val) {
  this->result = val;
}

uint32_t PlaceOrderResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlaceOrderResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlaceOrderResp");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlaceOrderResp &a, PlaceOrderResp &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

PlaceOrderResp::PlaceOrderResp(const PlaceOrderResp& other36) {
  ret_code = other36.ret_code;
  result = other36.result;
  __isset = other36.__isset;
}
PlaceOrderResp& PlaceOrderResp::operator=(const PlaceOrderResp& other37) {
  ret_code = other37.ret_code;
  result = other37.result;
  __isset = other37.__isset;
  return *this;
}
void PlaceOrderResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlaceOrderResp(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


