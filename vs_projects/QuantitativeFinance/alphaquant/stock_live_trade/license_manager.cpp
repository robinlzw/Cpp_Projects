// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <time.h>
#include <map>
#include <sstream>

#include <thrift/Thrift.h>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "AlphaConfig.h"
#include "GWin32CriticalSection.h"
#include "GScopedLock.h"
#include "GWin32Thread.h"
#include "utility.h"
#include "signature.h"

#include "license_manager.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

boost::shared_ptr<LicenseManager> g_license_data_ptr(new LicenseManager());

boost::shared_ptr<LicenseManager> LicenseManager::get_instance()
{
	return g_license_data_ptr;
}

LicenseManager::LicenseManager()
{
	m_max_allowed_fund = 200000.009;
	m_expire_time = time(NULL)+15*24*60*60;
	//m_money_left = 0.0;

	m_started = false;
		
}

bool LicenseManager::license_ok(int32_t& code, std::string& msg)
{
	
	double total_money_left = get_money_left();
	
	ScopedLock lck(m_critical_sec);

	if (total_money_left > m_max_allowed_fund) {
		code = 9;
		return false;
	}

	code = 0;
	return true;
}

double LicenseManager::get_money_left()
{
	double total_money_left = 0;

	ScopedLock lck(m_critical_sec);

	std::map<std::string, double>::iterator iter;
	for (iter = m_account_money_left_map.begin(); iter != m_account_money_left_map.end(); ++iter) {
		total_money_left += iter->second;
	}

	return total_money_left;
}

void LicenseManager::set_session_id(const std::string& id)
{
	ScopedLock lck(m_critical_sec);

	m_session_id = id;
}

std::string LicenseManager::get_session_id()
{
	ScopedLock lck(m_critical_sec);

	return m_session_id;
}

std::vector<boost::tuple<std::string, uint16_t>> LicenseManager::get_broker_server(const std::string &broker)
{
	std::vector<boost::tuple<std::string, uint16_t>> server_vec;

	ScopedLock lck(m_critical_sec);

	std::map<std::string, std::vector<ServerItem>>::iterator iter = m_broker_server.find(broker);
	if (iter != m_broker_server.end()) {
		for (int i = 0; i < iter->second.size(); ++i) {
			server_vec.push_back(boost::make_tuple(iter->second[i].host, iter->second[i].port));
		}
	}

	return server_vec;
}

std::string get_str1()
{
	std::vector <std::string> vec_mac;
	getWin32MacAddresses(vec_mac);

	std::string str1;
	for (int i = 0; i < vec_mac.size(); ++i) {
		str1 += vec_mac[i];
	}

	return str1;
}

u_long WINAPI LicenseManager::FetchConfigThreadProc(LPVOID lParam)
{
	std::string last_session_id;
	time_t last_get_config = 0;
	time_t last_report = time(NULL) - 24*60*60;

	LicenseManager *pthis = (LicenseManager*)lParam;

	do {
		bool fetch_data = false;
		do {
			ScopedLock lck(pthis->m_critical_sec);

			if (last_session_id != pthis->m_session_id) {
				last_session_id = pthis->m_session_id;
				fetch_data = true;
			}

			if (time(NULL) - last_get_config > 10 * 60 * 60) {
				fetch_data = true;
			}

		} while (false);

		std::string str1 = get_str1();

		if (fetch_data) {

			try {
				boost::shared_ptr<TTransport> socket(new TSocket("config.alpha-qt.com", 61118));
				//boost::shared_ptr<TTransport> socket(new TSocket("192.168.3.2", 61118));
				boost::shared_ptr<TTransport> transport(new TFramedTransport(socket));
				boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
				AlphaConfigClient client(protocol);


				transport->open();

				ConfigData cd;
				client.GetConfig(cd, str1, last_session_id);

				std::string raw_data = str1 + last_session_id + cd.license_data["mxf"] + cd.license_data["xpr"];
				std::string signature = cd.license_data["sgn"];
				//verify signature

				//bool signature_ok = true;//TODO
				bool signature_ok = pkc_verify_with_key((const unsigned char*)raw_data.c_str(), raw_data.size(), (const unsigned char*)signature.c_str(), signature.size());


				ScopedLock lck(pthis->m_critical_sec);
				pthis->m_license_data = cd.license_data;
				pthis->m_broker_server = cd.broker_server;

				if (signature_ok) {
					pthis->m_expire_time = atoi(cd.license_data["xpr"].c_str());
					if (time(NULL) < pthis->m_expire_time) {
						pthis->m_max_allowed_fund = atof(cd.license_data["mxf"].c_str());
					}
				}

				last_get_config = time(NULL);

			}
			catch (...) {
				//TODO
			}

		}

		double money_left = pthis->get_money_left();
		if (time(NULL) - last_report > 10 * 60 * 60 && money_left > 0) {
			last_report = time(NULL);

			try {
				boost::shared_ptr<TTransport> socket(new TSocket("config.alpha-qt.com", 61118));
				//boost::shared_ptr<TTransport> socket(new TSocket("192.168.3.2", 61118));
				boost::shared_ptr<TTransport> transport(new TFramedTransport(socket));
				boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
				AlphaConfigClient client(protocol);

				transport->open();

				std::map<std::string, std::string> data_map;

				do {
					ScopedLock lck(pthis->m_critical_sec);
					
					std::ostringstream oss_an;
					oss_an << pthis->m_account_money_left_map.size();
					std::ostringstream oss_tm;
					oss_tm << money_left;
					//Please do not remove the following code, we want to know how many users are using our software. 
					//Dont worry about your privacy. We only know your mac address and fund scale.
					data_map["str1"] = str1;//mac address
					data_map["str2"] = pthis->m_session_id;// this is the StartSDK param passed in
					data_map["an"] = oss_an.str();
					data_map["tm"] = oss_tm.str();//fund scale
				} while (0);

				client.Report(data_map);
			}
			catch (...) {
				//TODO
			}
		}

		Win32Thread::Sleep(3000);

	} while (true);

	return 0;
}

void LicenseManager::start()
{
	if (m_started)
		return;

	m_started = true;

	m_thread.StartThread(FetchConfigThreadProc, this);
}

void LicenseManager::set_account_money(const std::string& account, double money)
{
	ScopedLock lck(m_critical_sec);

	m_account_money_left_map[account] = money;
}